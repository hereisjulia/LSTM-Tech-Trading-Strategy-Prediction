---
title: "Backtest&Strategies"
author: "Julia"
date: "2024-01-10"
output: html_document
---
# Strategies Building

## Data Cleaning
```{r data cleaning}
library(readxl)
library(tidyverse)
stock_data <- read_excel("Raw data from BBG.xlsx", sheet = 2)
colnames(stock_data) <- as.character(unlist(stock_data[1, ]))
stock_data <- stock_data[-1,]

SNPS_data <- stock_data[1:6]
IBM_data <- stock_data[7:12]
MSFT_data <- stock_data[13:18]
#GOOGL_data <- stock_data[16:20]
#NVDA_data <- stock_data[21:25]

comp_list <- list(SNPS_data, IBM_data, MSFT_data) #, GOOGL_data, NVDA_data)
list_names <- c("SNPS", "IBM", "MSFT") #, "GOOGL", "NVDA")
names(comp_list) <- list_names

library(TTR) # for EWM

origin_date <- as.Date("1899-12-30")

convert_data <- function(data, origin_date) {
  data$Date <- as.numeric(as.character(data$Date))
  data$Date <- origin_date + data$Date - 2
  data$Open <- as.numeric(as.character(data$Open))
  data$High <- as.numeric(as.character(data$High))
  data$Low <- as.numeric(as.character(data$Low))
  data$Close <- as.numeric(as.character(data$Close))
  data$Volume <- as.numeric(data$Volume)
  return(data)
}

for (n in seq_along(comp_list)){
  comp_list[[n]] <- convert_data(comp_list[[n]], origin_date)
}
```

## Function: calculate_indicators 

-- This will give the actual continuous values
```{r function}
calculate_indicators <- function(data){
  
  # MACD # 移動平均
  EMA12 <- EMA(data$Close, n=12) # 12 days of moving average
  EMA26 <- EMA(data$Close, n=26) # 26 days of moving average
  fast <- EMA12 - EMA26  # 快線
  slow <- EMA(fast, n=9) # 慢線 (快線取9天移動平均)
  data$MACD <- fast - slow # diff between fast and slow
  
  # RSI 
  ##上漲的下跌的分開算移動平均
  data$diff <- c(NA, diff(data$Close))
  up <- ifelse(is.na(data$diff), 0, ifelse(data$diff >= 0, 1*data$diff, 0))
  down <- ifelse(is.na(data$diff), 0, ifelse(data$diff < 0, -1*data$diff, 0))
  
  up_EMA14 <- EMA(up, n=14)
  down_EMA14 <- EMA(down, n=14)
  RS14 <- up_EMA14 / down_EMA14 #平均gain除以loss ## RS- relative strength 相對強度
  data$RSI14 <- 100 * (RS14 / (1 + RS14))
  
  up_EMA7 <- EMA(up, n=7) #只是用來看黃金&死亡交叉
  down_EMA7 <- EMA(down, n=7)
  RS7 <- up_EMA7 / down_EMA7
  data$RSI7 <- 100 * (RS7 / (1 + RS7))
  #以50為分水嶺
  
  # KD 
  ## 近期最小及最大值
  rolling_min <- rep(NA, length(data$Close)) # create a column filled with NAs as long as Close
  rolling_max <- rep(NA, length(data$Close))
  data$RSV <- rep(NA, length(data$Close))
  
  for(i in 1:length(data$Close)) {
    ## find min/max in rolling 9 days
    rolling_min[i] <- ifelse(i < 9, min(data$Close[1:i], na.rm = TRUE), min(data$Close[(i-8):i], na.rm = TRUE))
    rolling_max[i] <- ifelse(i < 9, max(data$Close[1:i], na.rm = TRUE), max(data$Close[(i-8):i], na.rm = TRUE))
    data$RSV[i] <- ((data$Close[i] - rolling_min[i])/(rolling_max[i] - rolling_min[i]))*100
  } # RSV是最近9天的最大值最小值
    
  data$K <- rep(50, nrow(data))
  data$D <- rep(50, nrow(data))
    
  for(i in 2:nrow(data)) {
    data$K[i] <- (2/3 * data$K[i-1]) + (1/3 * data$RSV[i])
    data$D[i] <- (2/3 * data$D[i-1]) + (1/3 * data$K[i])
  }
  
  # OBV
  OBV <- ifelse(data$diff >0, data$Volume, ifelse(data$diff < 0, -data$Volume, 0))
  OBV[1] <- 0
  data$OBV <- cumsum((OBV))
  
  return(data)
}
```

```{r}
for (i in seq_along(comp_list)){
  comp_list[[i]] <- calculate_indicators(comp_list[[i]])
}
SNPS_data <- comp_list$SNPS
IBM_data <- comp_list$IBM
MSFT_data <- comp_list$MSFT

View(SNPS_data)
```

## Label the Signals

### MACD
```{r}
MACD_signal <- function(data){
  
  changes <- c(0, diff(sign(data$MACD)))
  temp_signal <- with(data, ifelse(changes == -2, -1, ifelse(changes == 2, 1, 0)))
  temp_signal[is.na(changes)] <- NA
  
  data$signal_MACD <- NA
  last_mark <- NA
  
  for(i in 1:nrow(data)) {
    if(!is.na(temp_signal[i])) {
      if(temp_signal[i] != 0) {
        last_mark <- temp_signal[i]
      }
      data$signal_MACD[i] <- last_mark
    }
  }
  
  return(data)
}

for (n in seq_along(comp_list)){
  comp_list[[n]] <- MACD_signal(comp_list[[n]])
}
```

### RSI
```{r}
RSI_signal <- function(data){
  
  DIFF <- data$RSI7 - data$RSI14
  changes <- c(0, diff(sign(DIFF)))
  temp_signal <- with(data, ifelse(changes == -2, -1, ifelse(changes == 2, 1, 0)))
  temp_signal[is.na(changes)] <- NA
  
  data$RSI_cross <- NA
  last_mark <- NA
  
  for(i in 1:nrow(data)) {
    if(!is.na(temp_signal[i])) {
      if(temp_signal[i] != 0) {
        last_mark <- temp_signal[i]
      }
      data$RSI_cross[i] <- last_mark
    }
  }
  
  data$signal_RSI <- ifelse(data$RSI14 < 30 & data$RSI_cross == 1, 1,
                     ifelse(data$RSI14 > 70 & data$RSI_cross == -1, -1, 0))
  
  last_signal <- NA
  for(i in 1:nrow(data)) {
    if(!is.na(data$signal_RSI[i])) {
      if(data$signal_RSI[i] == 1) {
        last_signal <- 1
      } else if(data$signal_RSI[i] == -1) {
        last_signal <- -1
      }
      data$signal_RSI[i] <- ifelse(is.na(last_signal), data$signal_RSI[i], last_signal)
    }
  }
  
  return(data)
}

for (n in seq_along(comp_list)){
  comp_list[[n]] <- RSI_signal(comp_list[[n]])
}
```

### KD
```{r}
KD_signal <- function(data){
  
  DIFF <- data$K - data$D
  changes <- c(0, diff(sign(DIFF)))
  temp_signal <- with(data, ifelse(changes == -2, -1, ifelse(changes == 2, 1, 0)))
  temp_signal[is.na(changes)] <- NA
  
  data$signal_KD <- NA
  last_mark <- NA
  
  for(i in 1:nrow(data)) {
    if(!is.na(temp_signal[i])) {
      if(temp_signal[i] != 0) {
        last_mark <- temp_signal[i]
      }
      data$signal_KD[i] <- last_mark
    }
  }
  
  return(data)
}

for (n in seq_along(comp_list)){
  comp_list[[n]] <- KD_signal(comp_list[[n]])
}
```

### OBV

```{r}
OBV_signal <- function(data){
  data$signal_OBV <- rep(0, length(data$Close))
  
  # Bullish Accumulation Signal
  n <- length(data$OBV)
  
  
  #Bullish Divergence Signal during Price Decline
  data$signal_OBV[data$Close < lag(data$Close) & data$OBV > lag(data$OBV) & data$OBV > 0] <- 1
  
  #Bearish Divergence Signal during Price Increase
  data$signal_OBV[data$Close > lag(data$Close) & data$OBV < lag(data$OBV)] <- -1
  
  #Bullish Trend Signal
  data$signal_OBV[data$OBV > lag(data$OBV) & data$Close > lag(data$Close)] <- 1

  #Bearish Signal during OBV Acceleration
  data$signal_OBV[c(NA, diff(diff(data$OBV))) > 0 & c(NA, diff(diff(data$Close))) <= 0] <- -1
  
  return(data)
}

for (n in seq_along(comp_list)){
  comp_list[[n]] <- OBV_signal(comp_list[[n]])
}

View(comp_list$SNPS)
```

```{r}
nrow(comp_list$SNPS["OBV_signal"==-1,])
```

```{r}
SNPS_data <- comp_list$SNPS
IBM_data <- comp_list$IBM
MSFT_data <- comp_list$MSFT
```






# Backtest

```{r}
# data should include the signal outcomes, the price of the stock

library(lubridate)
start_date <- as.Date("2010-04-19")
initial_capital <- 10000

signal_return <- function(data, start_date, signal_name){
  data$Date <- as.Date(data$Date)
  data <- data[data$Date >= start_date, ]
  current_capital <- initial_capital
  stock_held <- 0
  previous_signal <- 0
  
  # Assumption: no short sell.
  for (i in 1:nrow(data)){
    current_signal <- data[[signal_name]][i]
    current_price <- data$Close[i]
    
    if (current_signal == 1 & previous_signal != 1){
      stock_held <- floor(current_capital / current_price)
      current_capital <- current_capital - stock_held * current_price
    }
    
    if (current_signal == -1 & stock_held > 0){
      current_capital <- current_capital + stock_held * current_price
      stock_held <- 0
    }
    
    previous_signal <- current_signal
  }
  
  latest_capital <- current_capital + (stock_held * data$Close[nrow(data)])
  
  signal_return <- round((latest_capital - initial_capital) / initial_capital * 100,2)
  annualized_return <- round((latest_capital/initial_capital)^(365/as.numeric((max(data$Date)-min(data$Date))))-1, 4)*100
  
  return(c(signal_return, annualized_return))
}
```


```{r}
signals <- c("signal_MACD", "signal_RSI", "signal_KD")
signal_returns <- matrix(0, nrow = length(signals), ncol = length(list_names))
rownames(signal_returns) <- list_names
colnames(signal_returns) <- signals

for (j in 1:length(signals)){
  for(i in 1:length(list_names)) {
    current_data <- comp_list[[list_names[i]]]
    signal_returns[i, j] <- signal_return(current_data, start_date, signals[j])[1]
  }
}
signal_returns <- t(signal_returns)


# Annualized Return (%)
annualized_return <- matrix(0, nrow = length(signals), ncol = length(list_names))
rownames(annualized_return) <- list_names
colnames(annualized_return) <- signals

for (j in 1:length(signals)){
  for(i in 1:length(list_names)) {
    current_data <- comp_list[[list_names[i]]]
    annualized_return[i, j] <- signal_return(current_data, start_date, signals[j])[2]
  }
}

annualized_return <- t(annualized_return)

print(signal_returns)
print(annualized_return)
```

```{r}


```










